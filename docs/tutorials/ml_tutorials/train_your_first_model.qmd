---
title: 'Train your first model'
description: "Build a classifier with the Iris dataset using Xorq's ML workflow"
icon: "stars"
headline: "Start your ML journey"
---

This tutorial guides you through training your first machine learning model with Xorq. You'll use the classic Iris dataset to build a classifier that predicts flower species.

By the end, you'll know how to load data, train a model, and make predictions using Xorq's ML workflow.

## What makes Xorq ML different?

Xorq wraps scikit-learn models so they work with deferred execution. This means you can build complex training pipelines that cache intermediate results and run on different backends—all while using familiar scikit-learn APIs.

Think of Xorq as a bridge between SQL-style data transformations and ML training. You write your ML code once, and Xorq handles optimization.

:::{.callout-tip}
### Deferred execution for ML
Just like data operations, model training in Xorq is deferred. This lets Xorq cache trained models, optimize data flow, and manage resources efficiently.
:::

## Load your training data

Let's start with the Iris dataset. This dataset contains measurements of iris flowers and their species labels.

```{python}
import xorq.api as xo

# <1>
con = xo.connect()

# <2>
iris = xo.examples.iris.fetch(backend=con)

# <3>
print("Dataset shape:")
print(f"Columns: {iris.columns}")
print(f"Row count: {iris.count().execute()}")
print("\nFirst few rows:")
print(iris.head(3).execute())
```
1. Connect to the embedded backend for local computation.
2. Load the Iris dataset—this creates a table expression.
3. Inspect the data structure and preview rows.

The Iris dataset has four feature columns (sepal length, sepal width, petal length, petal width) and one target column (species).

## Prepare features and target

Before training, separate your features from the target variable.

```{python}
# <1>
target = "species"
features = tuple(iris.drop(target).columns)

# <2>
print(f"Features: {features}")
print(f"Target: {target}")
```
1. Define which column is the target and which are features.
2. Verify the split looks correct.

This separation tells Xorq which columns to use for training (features) and which column to predict (target).

## Create a model step

Xorq uses the `Step` class to wrap scikit-learn estimators. A `Step` knows how to fit a model using Xorq expressions.

```{python}
from sklearn.neighbors import KNeighborsClassifier
from xorq.expr.ml import Step

# <1>
classifier = KNeighborsClassifier(n_neighbors=5)

# <2>
model_step = Step(typ=KNeighborsClassifier, n_neighbors=5)

# <3>
print(f"Step created: {model_step}")
print(f"Underlying classifier: {model_step.typ}")
```
1. Create a standard scikit-learn classifier (for reference).
2. Wrap it in a Xorq `Step` with the same parameters.
3. Inspect the step to see what it contains.

The `Step` class takes the classifier type and any parameters you'd normally pass to the scikit-learn constructor.

:::{.callout-note}
### Step vs scikit-learn estimator
A `Step` wraps a scikit-learn estimator so it works with Xorq's deferred execution. You use the same parameters as the original estimator.
:::

## Fit the model

Now train the model on your data. The `.fit()` method returns a fitted step that can make predictions.

```{python}
# <1>
fitted_step = model_step.fit(
    expr=iris,
    features=features,
    target=target
)

# <2>
print("Model fitted!")
print(f"Fitted step type: {type(fitted_step)}")
```
1. Fit the model using the Iris expression—computation happens here.
2. The result is a fitted step ready for predictions.

When you call `.fit()`, Xorq:
- Executes the expression to get training data
- Extracts feature columns and target column
- Trains the scikit-learn model
- Wraps the trained model in a `FittedStep`

## Make predictions

Use the fitted model to predict species for the same data (in practice, you'd use a test set).

```{python}
# <1>
predictions_expr = iris.mutate(
    predicted=fitted_step.predict_raw(iris, name="predicted")
)

# <2>
predictions = predictions_expr.execute()

# <3>
print("\nPredictions:")
print(predictions[["species", "predicted"]].head(10))
```
1. Add a prediction column using the fitted step's `.predict_raw()` method.
2. Execute to see actual predictions.
3. Compare true species with predicted species.

The `.predict_raw()` method creates a column expression that applies the model to your data.

:::{.callout-tip}
### Predict without executing
Notice how predictions are also deferred! We built the prediction expression first, then executed it. This lets you chain predictions with other operations before running anything.
:::

## Evaluate accuracy

Let's check how well the model performs.

```{python}
# <1>
correct_predictions = (
    predictions_expr
    .mutate(correct=xo._.species == xo._.predicted)
    .agg(
        total=xo._.species.count(),
        correct_count=xo._.correct.sum().cast("int64"),
    )
    .mutate(accuracy=xo._.correct_count / xo._.total)
)

# <2>
result = correct_predictions.execute()
print(f"\nAccuracy: {result['accuracy'][0]:.2%}")
print(f"Correct: {result['correct_count'][0]} out of {result['total'][0]}")
```
1. Build an expression that calculates accuracy—still deferred!
2. Execute to see the final accuracy score.

Your model's accuracy depends on the random initialization of KNeighborsClassifier. Typically, you'd see 90%+ accuracy on the Iris dataset.

## Complete example

Here's the full workflow in one place:

```python
import xorq.api as xo
from sklearn.neighbors import KNeighborsClassifier
from xorq.expr.ml import Step

# Load data
con = xo.connect()
iris = xo.examples.iris.fetch(backend=con)

# Prepare features and target
target = "species"
features = tuple(iris.drop(target).columns)

# Create and fit model
model_step = Step(typ=KNeighborsClassifier, n_neighbors=5)
fitted_step = model_step.fit(
    expr=iris,
    features=features,
    target=target
)

# Make predictions
predictions_expr = iris.mutate(
    predicted=fitted_step.predict_raw(iris, name="predicted")
)

# Execute and view results
predictions = predictions_expr.execute()
print(predictions[["species", "predicted"]].head(10))
```

## Next steps

You've trained your first model with Xorq! Continue learning:

- [Understand Step and Pipeline](understand_step_and_pipeline.qmd) explains the ML abstractions in depth
- [Use deferred fit and predict](use_deferred_fit_predict.qmd) shows advanced deferred execution patterns for ML
- [Split data for training](split_data_for_training.qmd) demonstrates proper train/test splits
