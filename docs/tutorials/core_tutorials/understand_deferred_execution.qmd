---
title: 'Understand deferred execution'
---

This tutorial helps you understand when Xorq runs computation versus when it builds expressions. You'll see hands-on how deferred execution works and why it matters.

By the end, you'll know exactly when your code triggers actual computation.

## What is deferred execution?

Deferred execution means Xorq waits to run computations until you explicitly ask for results. When you chain operations like `.filter()` and `.group_by()`, Xorq builds an expression graph but doesn't execute anything yet.

This approach gives Xorq time to optimize your query before running it. Think of it like planning a route before driving—you get to see the whole journey and choose the best path.

:::{.callout-tip}
### Why defer?
Deferred execution lets Xorq eliminate unnecessary steps, push computations to faster backends, and cache intermediate results. You write clear code, and Xorq handles the optimization.
:::

## Build expressions without executing

Let's build an expression that loads and filters data. Notice how we can create the expression without triggering any computation.

```{python}
import xorq.api as xo

# <1>
con = xo.connect()

# <2>
iris = xo.examples.iris.fetch(backend=con)

# <3>
filtered = iris.filter(xo._.sepal_length > 6)

# <4>
print(f"Expression type: {type(filtered)}")
print(f"Has this executed? Not yet!")
```
1. Connect to the embedded backend.
2. Load the iris dataset—this creates a table reference, not the actual data.
3. Build a filter expression. Still no computation!
4. Print the expression type to confirm it's just an expression object.

At this point, Xorq knows what you want to do (filter rows), but it hasn't read any data or applied any filters.

## Inspect the expression

You can look at what operations Xorq has queued up by examining the expression.

```{python}
# <1>
print("\nExpression structure:")
print(filtered)

# <2>
print(f"\nBackends involved: {filtered.ls.backends}")
```
1. Print the expression to see the operation tree.
2. Check which backends this expression would use.

The output shows you the chain of operations Xorq will perform when you execute. This is your expression graph.

## Execute and observe computation

Now let's trigger actual computation by calling `.execute()`. This is when Xorq runs your query.

```{python}
# <1>
print("\nBefore execute: building plan...")

# <2>
result = filtered.execute()

# <3>
print(f"After execute: got results!")
print(f"Result type: {type(result)}")
print(f"Number of rows: {len(result)}")
print(result.head(5))
```
1. We're about to trigger computation.
2. This line executes the expression—computation happens here!
3. We now have actual results, not just an expression.

The moment you called `.execute()`, Xorq:
- Compiled your expression into an execution plan
- Loaded the data from the iris dataset
- Applied the filter
- Returned the results as a PyArrow Table

:::{.callout-note}
### Execution is explicit
Xorq never runs queries behind your back. You control exactly when computation happens by calling `.execute()` or similar methods like `.to_pandas()` or `.to_pyarrow()`.
:::

## Build complex expressions

Let's build a more complex expression with multiple operations. Watch how Xorq still defers everything.

```{python}
# <1>
complex_expr = (
    iris
    .filter(xo._.sepal_length > 5.5)
    .mutate(sepal_ratio=xo._.sepal_length / xo._.sepal_width)
    .group_by("species")
    .agg(
        avg_ratio=xo._.sepal_ratio.mean(),
        count=xo._.species.count()
    )
)

# <2>
print("Built complex expression (not executed yet):")
print(complex_expr)

# <3>
print("\nNow executing...")
result = complex_expr.execute()
print(result)
```
1. Build an expression with filtering, adding a column, grouping, and aggregating.
2. The expression exists, but no computation has run.
3. Execute and see all operations run at once.

Xorq deferred all five operations (filter, mutate, group, two aggregations) until you called `.execute()`. This gives it room to optimize the entire workflow.

## Compare: immediate vs deferred

Let's see what happens if you force early execution versus deferring.

```{python}
# <1>
immediate = iris.filter(xo._.sepal_length > 6).execute()  # Executes immediately

# <2>
print(f"Immediate approach - first result type: {type(immediate)}")
print(f"This is already executed data (pandas DataFrame), not an expression!")
print(f"Cannot chain more Xorq operations on this DataFrame")

# <3>
deferred = (
    iris
    .filter(xo._.sepal_length > 6)
    .group_by("species")
    .agg(xo._.sepal_width.sum())
)

# <4>
print(f"\nDeferred approach - expression type: {type(deferred)}")
print(f"This is an expression that can still be optimized!")
print(f"Can chain more operations or execute when ready")
```
1. Execute early by calling `.execute()` after the first operation.
2. You now have materialized data, not an expression.
3. Build the full expression without executing.
4. This stays as an expression until you explicitly execute it.

The deferred approach lets Xorq optimize the entire pipeline. The immediate approach locks in results after each step, preventing optimization.

:::{.callout-warning}
### Avoid premature execution
If you execute too early, you lose the benefits of deferred execution. Let Xorq see your full query before running it.
:::

## Complete example

Here's a full example showing deferred execution in action:

```python
import xorq.api as xo

# Connect and load data
con = xo.connect()
iris = xo.examples.iris.fetch(backend=con)

# Build expression (deferred—no computation yet)
expr = (
    iris
    .filter(xo._.sepal_length > 5.5)
    .group_by("species")
    .agg(avg_width=xo._.sepal_width.mean())
)

# Inspect without executing
print("Expression ready:", type(expr))

# Execute when you're ready
result = expr.execute()
print("Results:", result)
```

## Next steps

Now you understand deferred execution. Continue exploring:

- [Explore caching](explore_caching.qmd) shows how deferred execution enables intelligent caching
- [Your first build](your_first_build.qmd) explains how Xorq captures expressions as portable manifests
- [Switch backends](switch_backends.qmd) demonstrates how deferred execution works across different engines

