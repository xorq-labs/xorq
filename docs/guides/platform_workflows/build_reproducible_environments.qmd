---
title: 'Build reproducible environments'
---

Use `xorq build` with `uv` to create reproducible builds with locked dependencies. The same build hash runs identically across development, staging, and production, reducing environment-related failures.

:::{.callout-tip}
If you haven't installed Xorq yet, then see the [installation guide](../../getting_started/installation.qmd) for setup instructions. You'll also need [uv](https://github.com/astral-sh/uv) installed.
:::


## Configure uv for Xorq projects

To get reproducible builds, you first need uv to own and describe your project’s Python environment. This section sets up uv so every later build uses the same dependencies and Python version.

### Initialize uv project

Tell uv what your Xorq project is and which Python and dependency set it should manage. You do this once per project by creating a `pyproject.toml` file in the project root.

Create a `pyproject.toml` for your project:

```toml
[project]
name = "my-xorq-pipeline"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "xorq",
    "pandas",
    "scikit-learn",
]
```

### Lock dependencies

Once uv knows about your project, lock the dependency graph so every build uses the same versions:

```bash
uv lock
```

This command creates a `uv.lock` file with exact versions; commit it so uv can reliably recreate the same environment on any machine.

### Optional: use a minimal example expression

If you don't yet have a real pipeline to build, you can use a small example expression so you can follow the rest of this guide end to end. Create a file called `train_model.py` in your project root with this content:

```python
import pandas as pd
import xorq.api as xo


def _build_training_table() -> xo.Table:
    df = pd.DataFrame(
        {
            "feature": [1.0, 2.0, 3.0, 4.0],
            "label": [0.0, 0.0, 1.0, 1.0],
        }
    )
    return xo.memtable(df)


train_data = _build_training_table()

model_expr = train_data.mutate(
    feature_scaled=train_data.feature / 4.0,
)
```

The `model_expr` variable gives you a simple, self-contained expression that `xorq build` can package into a reproducible build.

## Build reproducible artifacts

With your environment defined and locked, you can now turn expressions into **reusable, reproducible build artifacts** using `xorq build`.

### Build your expression

Build your expression into a reproducible artifact:

```bash
xorq build train_model.py -e model_expr --builds-dir builds
```

The `xorq build` command creates a build directory with your expression graph and metadata, so you can run the same build hash consistently across machines and environments. Combined with `uv.lock` for dependency management, this ensures reproducible builds.

### Verify build artifacts

Check build artifacts:

```
ls builds/<build_hash>/
# expr.yaml
# memtables/
# metadata.json
# profiles.yaml
```

In this simple example, the build contains the expression graph (`expr.yaml`), a `memtables/` directory with in‑memory table data, and metadata/profile files. More complex builds may also include additional directories (for example `database_tables/`).

## Promote environments

After you can produce a reproducible build, the next concern is **moving that same build hash safely through dev → staging → prod**. This section shows how to use catalog aliases to promote one immutable build across environments.

### Build for development

Build and tag for development:

```bash
# Build expression
xorq build train_model.py -e model_expr --builds-dir builds
export BUILD_HASH=<hash_from_output>

# Add to catalog with dev alias
xorq catalog add builds/$BUILD_HASH --alias model-dev
```

### Promote to staging

Promote build to staging:

```bash
# Test dev build, then promote
xorq catalog add builds/$BUILD_HASH --alias model-staging
```

### Promote to production

Promote build to production:

```bash
# After staging validation, promote to prod
xorq catalog add builds/$BUILD_HASH --alias model-prod
```

Using aliases (`model-dev`, `model-staging`, `model-prod`) lets you move one immutable build through environments, while still being able to test at each stage and roll back by pointing an alias at an earlier hash.

## Debug environment issues

Even with uv, environment or dependency problems can still surface. This section focuses on **diagnosing and fixing issues without breaking reproducibility**.

### Check build environment

Verify build environment:

```bash
# Check Python version
python --version

# Check installed packages
pip list

# Check uv environment
uv pip list
```

### Verify dependencies

Check dependency resolution:

```bash
# Check lock file
cat uv.lock

# Verify dependencies match
uv sync --dry-run
```

### Rebuild with clean environment

Rebuild with clean environment:

```bash
# Remove existing build
rm -rf builds/<build_hash>

# Rebuild
xorq build train_model.py -e model_expr --builds-dir builds
```

Checking the Python version, installed packages, uv environment, and then rebuilding if needed confirms that the environment really matches the locked configuration; when in doubt, deleting an old build and re‑running `xorq build` gives you a clean, reproducible baseline.

## Integrate with CI/CD

To truly eliminate “works on my machine,” you need CI/CD to run the same reproducible builds. This section wires `xorq build` into a GitHub Actions pipeline so every commit produces and verifies the same artifacts.

### GitHub Actions example

Automate builds in CI:

```yaml
name: Build and Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      
      - name: Install Xorq
        run: uv pip install xorq
      
      - name: Build expression
        run: |
          BUILD_HASH=$(xorq build train_model.py -e model_expr --builds-dir builds | grep -o 'builds/[a-f0-9]*' | cut -d'/' -f2)
          echo "BUILD_HASH=$BUILD_HASH" >> $GITHUB_ENV
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: builds/${{ env.BUILD_HASH }}
```

Running `xorq build` in CI with `uv.lock` ensures consistent dependency versions for every commit, and uploading the build directory lets your deployment system consume the exact artifacts that passed tests.

### Build verification

Verify builds in CI:

```yaml
- name: Verify build
  run: |
    # Test build can be loaded
    xorq catalog add builds/$BUILD_HASH --alias test-build
    
    # Run verification tests
    python verify_build.py builds/$BUILD_HASH
```

The verification step proves that the build can be loaded and exercised in a clean environment; if it fails here, you catch the issue before it reaches staging or production.

## Team workflow with uv builds

Reproducible builds are most valuable when the whole team shares them. This section shows how to **distribute and track uv builds** so teammates and deployment systems all run the same artifacts.

### Share builds

Share build directories with team:

```bash
# Build expression
xorq build train_model.py -e model_expr --builds-dir builds
export BUILD_HASH=<hash_from_output>

# Share build directory
tar -czf build-$BUILD_HASH.tar.gz builds/$BUILD_HASH/
# Share tar.gz with team
```

Sharing the build directory (or an archive of it) means teammates and automated jobs can run the exact same artifacts without having to rebuild or guess at dependencies.

### Version control

Track builds in version control:

```bash
# Add build to git (optional, for small builds)
git add builds/$BUILD_HASH/

# Or track build hashes
echo "$BUILD_HASH" >> .builds.txt
git add .builds.txt
```

Tracking build hashes (and committing lock files) in version control gives you an auditable history of which artifacts were deployed where and how they were produced.

## Troubleshooting

If something still goes wrong, these troubleshooting recipes help you get back to a clean, reproducible state without guessing at environment differences.

### Issue: Dependency resolution fails

**Error**: uv cannot resolve dependencies

**Cause**: Conflicting dependencies or missing packages

**Recovery**:

1. Check `pyproject.toml`: verify dependency specifications
2. Update lock file: run `uv lock` to regenerate
3. Check Python version: ensure version matches requirements
4. Review dependency conflicts: resolve version conflicts

**Prevention**:

- Keep `pyproject.toml` and `uv.lock` in version control
- Regularly update lock file
- Test dependency resolution locally

### Issue: Build fails in CI but works locally

**Error**: Build succeeds locally but fails in CI

**Cause**: Environment differences or missing dependencies

**Recovery**:

1. Check CI environment: verify Python version and packages
2. Use `uv.lock`: ensure consistent dependency versions
3. Check lock file: ensure lock file is committed
4. Replicate CI locally: use same environment as CI

**Prevention**:

- Commit `uv.lock` to version control
- Test builds in CI-like environment
- Document environment requirements

### Issue: Build artifacts differ across machines

**Error**: Same build produces different results

**Cause**: Environment differences or non-deterministic builds

**Recovery**:

1. Use `uv.lock`: ensure consistent dependency versions
2. Check dependencies: verify all dependencies are locked
3. Rebuild clean: remove old build and rebuild
4. Verify lock file: ensure lock file is used

**Prevention**:

- Lock all dependencies with `uv lock`
- Use consistent Python versions
- Document build process

## Next steps

You now have techniques for building reproducible environments, including uv configuration, dependency locking, environment promotion, and CI/CD integration.

- [Manage the compute catalog](manage_compute_catalog.qmd) - Organize and discover builds
- [Set up CI/CD pipelines](setup_cicd_pipelines.qmd) - Automate builds and deployments
- [Deploy models to production](../ml_workflows/deploy_models_to_production.qmd) - Deploy reproducible builds
