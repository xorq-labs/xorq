---
title: 'Profiles'
description: "Store and use connection settings via environment variable references"
---

Profiles store connection parameters as environment variable references (e.g. `${POSTGRES_HOST}`). You create, save, and load profiles; at connection time Xorq resolves the variables so credentials never live in code or in the profile file.

## Profile

A `Profile` is an immutable connection configuration you can serialize to disk.

### Properties

These attributes describe a saved profile.

| Property | Type | Description |
|----------|------|-------------|
| `con_name` | `str` | Backend name (e.g. `postgres`, `snowflake`) |
| `kwargs_tuple` | `tuple` | Connection parameters as key-value pairs |
| `kwargs_dict` | `dict` | Same parameters as a dictionary |
| `hash_name` | `str` | Unique hash for the profile |
| `idx` | `int` | Unique numeric identifier |

### Create a profile

Construct a profile from parameters, from an existing connection, or by loading from disk.

```{python}
#| eval: false

import xorq.api as xo
from xorq.vendor.ibis.backends.profiles import Profile

profile = Profile(
    con_name="postgres",
    kwargs_tuple=(
        ("host", "${POSTGRES_HOST}"),
        ("port", 5432),
        ("database", "postgres"),
        ("user", "${POSTGRES_USER}"),
        ("password", "${POSTGRES_PASSWORD}"),
    ),
)

# From an existing connection (e.g. postgres: Profile.from_con(xo.postgres.connect_env()))
profile = Profile.from_con(xo.connect())

# Load from disk by alias
profile = Profile.load("postgres_example")
```

### Instance methods

Call these on a `Profile` instance to get a connection, clone, or serialize.

```{python}
#| eval: false

connection = profile.get_con()
modified = profile.clone(connect_timeout=10)
profile_dict = profile.as_dict()
json_str = profile.as_json()
yaml_str = profile.as_yaml()
path = profile.save(alias="postgres_example", clobber=True)
```

## Profiles (collection)

Use `Profiles()` to list and access saved profiles by name. `list()` returns a tuple of profile names (aliases or hash stems). Use `get(name)`, attribute access, or dictionary access to load a profile.

```{python}
#| eval: false

from xorq.vendor.ibis.backends.profiles import Profiles

profiles = Profiles()
names = profiles.list()  # e.g. ("postgres_example", "feda6956..._1")
profile = profiles.get("postgres_example")
profile = profiles.postgres_example
profile = profiles["postgres_example"]
```

## How variables are resolved

Profiles store references (e.g. `${POSTGRES_PASSWORD}`), not values. Set the variables in your environment; `profile.get_con()` resolves them when creating the connection. This keeps secrets out of profile files.

```{python}
#| eval: false

import os

os.environ["POSTGRES_HOST"] = "examples.letsql.com"
os.environ["POSTGRES_USER"] = "letsql"
os.environ["POSTGRES_PASSWORD"] = "letsql"

profile = Profile(
    con_name="postgres",
    kwargs_tuple=(
        ("host", "${POSTGRES_HOST}"),
        ("port", 5432),
        ("database", "postgres"),
        ("user", "${POSTGRES_USER}"),
        ("password", "${POSTGRES_PASSWORD}"),
    ),
)

# Profile still shows the reference
print(profile.kwargs_dict["password"])  # "${POSTGRES_PASSWORD}"

# Connection resolves at creation time
conn = profile.get_con()
```

## Security

Profiles are safe to share and commit because they only store references.

- Profiles store references only; values are resolved when you call `get_con()`.
- You can commit profile files to version control.
- Use environment variables (or a secrets manager) for passwords, API keys, and tokens.
